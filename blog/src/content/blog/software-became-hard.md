---
title: "Software Became Hard — Now It's Becoming Soft Again"
description: "A short history of the word software and why its meaning is bending back to its origins"
pubDate: 'Nov 28 2025'
draft: false
---

Most people never think about why we call it *software*.
The name just feels... obvious.

But it wasn't obvious at all.

Supposedly, software started as a joke or a tongue-in-cheek contrast to *hardware*. This was because in 1958 nobody knew what to call this new invisible thing that told machines what to do. It wasn't mechanical. It wasn't physical. It wasn't something you could tighten with a wrench.

So they called it *soft*.

Not soft like a pillow — soft like squishy, malleable, non-concrete, still-forming.
It was the part of computing that was fluid, flexible, and easy to change.

At least at first.

## The Original Meaning: "Soft" as in Malleable

When John Tukey used the word in 1958, the defining characteristic of this new phenomenon was:

- It wasn't fixed.
- It wasn't permanent.
- It was shapeable logic, not metal.

Hardware was steel and silicon.
Software was ideas and instructions.

The legacy metaphor is clear:

- Hard things require fabrication.
- Soft things can be altered, molded, and iterated.

Early software embodied this. It was easy to change.
A small team could rewrite an entire system in weeks.
A single engineer could transform an application overnight.

*Soft* was the point.

## But Then Something Unexpected Happened

Software started eating the world.

And when demand outgrew the simplicity of early codebases, the nature of software began to shift:

- Codebases grew larger than any one person could hold in their head.

And then almost simulaneous in the industry.
- Software Architectures emerged.
- People managing parts of the architectures were needed.
- Business architectures to coincide with software architectures coincided.
- Teams expanded into roles: PMs, architects, designers, QA, analysts, scrum masters.
- Releases required planning, alignment, ceremonies, and handoffs.
- Changes became expensive.
- Refactoring became risky.
- The business depended more and more on digital systems that couldn't break.
- To procure the investments in these expenses extra planning, meetings were needed.

Software became... *hard*.

Hard because of its size.
Hard because of the coordination needed.
Hard because of the scarcity of people who could work on it.
Hard because of the cost of getting it wrong.

The irony...

> We named it "software" for its flexibility,
> then built an industry that made it rigid.

The cost of change rose so high that software felt more like architecture than clay.

## The Agentic Shift: Software Is Becoming Soft Again

Enter agentic programming.  IMO the most significant shift in software production since the compiler even more so then the cloud and whatever else.

Now:

- Code generation is cheap.
- Refactoring is safe and reversible.
- Prototyping takes minutes instead of months.
- Documentation and tests stay in sync automatically.
- Ideas can be explored before meetings even happen.
- A single engineer can produce what once required a team.

Feels like we are moving back to the idea of software being much more malleable.

Back to:

- trying ideas quickly
- reshaping systems rapidly
- evolving designs continuously
- bending the system instead of negotiating with it

The constraints that once made software hard seem to be dissolving:

- Team coordination overhead shrinks.
- The cost of iteration drops dramatically.
- The danger of change is mitigated by intelligent tooling.
- Agents can handle the drudgery, letting humans shape ideas again.

Software is returning to the fluidity it was named for.

With agentic tools, software is once again something you can mold, bend, reshape, and regenerate with ease.

In other words, it feels like it is becoming *soft* again.
