---
/* CourtDemo.astro */
const { maxWidth = 760 } = Astro.props; // set via <CourtDemo maxWidth={900} />
const uid = `court-${Math.random().toString(36).slice(2, 10)}`;
---

<style>
<style>
  .court-root {
    inline-size: 100%;
    display: grid;
    place-items: center;
  }

  .court {
    --court-w: var(--court-w-override, 760px);
    inline-size: min(100%, var(--court-w));
    aspect-ratio: 1 / 1;
    block-size: auto;
    background: #f6b080;
    border-radius: 16px;
    padding: 20px;
    position: relative;
    overflow: hidden;
    box-shadow:
      inset 0 0 0 2px rgba(0,0,0,0.15),
      0 30px 70px rgba(0,0,0,0.35);
  }

  .net {
    position: absolute;
    left: 0; right: 0;
    top: 50%;
    height: 2px;
    background: #0b5;
  }

  .fab {
    position: absolute;
    top: 14px;
    right: 14px;
    z-index: 3;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 14px;
    border: 0;
    border-radius: 999px;
    background: #174e6d;
    color: #fff;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 12px 28px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.12);
  }
  .fab:active { transform: translateY(1px); }
</style>

<!-- Make dynamic nodes (players) global so JS-created elements are styled -->
<style is:global>
  .player {
    position: absolute;
    width: 56px; height: 56px;
    border-radius: 16px;
    background: #11394f; /* bottom team */
    color: #fff;
    display: grid;
    place-items: center;
    user-select: none;
    cursor: grab;
    box-shadow: 0 10px 24px rgba(0,0,0,0.35), inset 0 0 0 2px rgba(255,255,255,0.08);
    transition: box-shadow 120ms ease;
  }
  .player.teamB { background: #3a2b57; } /* top team */
  .player:active {
    cursor: grabbing;
    box-shadow: 0 6px 16px rgba(0,0,0,0.45), inset 0 0 0 2px rgba(255,255,255,0.14);
  }

  .num { font-weight: 800; font-size: 18px; }
  .lab { font-size: 11px; opacity: .85; margin-top: -4px; }
</style>

<div id={uid} class="court-root" style={`--court-w-override: ${maxWidth}px`}>
  <div class="court" aria-label="Volleyball court with two teams">
    <button class="fab" type="button" aria-label="Reset positions">Reset</button>
    <div class="net"></div>
  </div>
</div>

<!-- Inject frontmatter vars into inline script -->
<script is:inline define:vars={{ uid }}>
/* Small helper: retry across a few frames until the element is mounted */
function findRoot(id, tries = 6) {
  const node = document.getElementById(id);
  if (node || tries <= 0) return Promise.resolve(node);
  return new Promise(res => requestAnimationFrame(() => res(findRoot(id, tries - 1))));
}

requestAnimationFrame(async () => {
  const __COURT_UID__ = uid; // provided by define:vars ✅
  const root = await findRoot(__COURT_UID__, 6);
  if (!root) { console.error("CourtDemo: root not found", __COURT_UID__); return; }

  const court = root.querySelector('.court');
  const resetBtn = root.querySelector('.fab');
  if (!court || !resetBtn) { console.error("CourtDemo: court/resetBtn missing"); return; }

  // --- Geometry helpers ---
  const PADDING = 20, size = 56, gapY = 24, gapX = 24;

  const W = () => court.clientWidth;
  const H = () => court.clientHeight;
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

  // --- Players & constraints ---
  const players = {
    1:{id:1,label:'RB',team:'bottom'}, 2:{id:2,label:'RF',team:'bottom'}, 3:{id:3,label:'MF',team:'bottom'},
    4:{id:4,label:'LF',team:'bottom'}, 5:{id:5,label:'LB',team:'bottom'}, 6:{id:6,label:'MB',team:'bottom'},
    11:{id:11,label:'RB',team:'top'}, 12:{id:12,label:'RF',team:'top'}, 13:{id:13,label:'MF',team:'top'},
    14:{id:14,label:'LF',team:'top'}, 15:{id:15,label:'LB',team:'top'}, 16:{id:16,label:'MB',team:'top'}
  };

  const constraints = [
    // Bottom
    { a:1, b:2, type:'behind', dir:+1 }, { a:6, b:3, type:'behind', dir:+1 }, { a:5, b:4, type:'behind', dir:+1 },
    { a:1, b:6, type:'rightOf', dir:+1 }, { a:6, b:5, type:'rightOf', dir:+1 }, { a:2, b:3, type:'rightOf', dir:+1 }, { a:3, b:4, type:'rightOf', dir:+1 },
    // Top mirrored
    { a:11, b:12, type:'behind', dir:-1 }, { a:16, b:13, type:'behind', dir:-1 }, { a:15, b:14, type:'behind', dir:-1 },
    { a:11, b:16, type:'rightOf', dir:-1 }, { a:16, b:15, type:'rightOf', dir:-1 }, { a:12, b:13, type:'rightOf', dir:-1 }, { a:13, b:14, type:'rightOf', dir:-1 }
  ];

  // --- Build DOM nodes for players ---
  const els = {};
  for (const id of Object.keys(players)) {
    const p = players[id];
    const el = document.createElement('div');
    el.className = 'player' + (p.team === 'top' ? ' teamB' : '');
    el.setAttribute('role', 'button');
    el.setAttribute('aria-grabbed', 'false');
    el.dataset.pid = id;
    const shown = p.team === 'top' ? (p.id - 10) : p.id; // show 1..6 both sides
    el.innerHTML = '<div class="num">'+shown+'</div><div class="lab">'+p.label+'</div>';
    court.appendChild(el);
    els[id] = el;
  }

  // --- Court half limits (no net crossing) ---
  const halfMinY = (team) => team === 'top' ? PADDING : (H()/2 + 2);
  const halfMaxY = (team) => team === 'top' ? (H()/2 - size - 2) : (H() - PADDING - size);

  // --- Position helpers ---
  function setPos(id, x, y){
    const team = players[id].team;
    const cx = clamp(x, PADDING, W() - PADDING - size);
    const cy = clamp(y, halfMinY(team), halfMaxY(team));
    const el = els[id];
    el.dataset.x = cx; el.dataset.y = cy;
    el.style.transform = 'translate('+cx+'px,'+cy+'px)';
  }
  const getPos = (id) => {
    const el = els[id];
    return { x: parseFloat(el.dataset.x || '0'), y: parseFloat(el.dataset.y || '0') };
  };

  // --- Constraint solver ---
  function satisfyAll(maxIters = 28){
    console.log('called');
    for (let k = 0; k < maxIters; k++) {
      let any = false;
      for (const c of constraints) {
        const A = getPos(c.a), B = getPos(c.b);
        if (c.type === 'behind') {
          if (c.dir === +1) {
            if (A.y < B.y + gapY) {
              const newBy = clamp(A.y - gapY, halfMinY(players[c.b].team), halfMaxY(players[c.b].team));
              if (newBy !== B.y) { setPos(c.b, B.x, newBy); any = true; continue; }
              const newAy = clamp(B.y + gapY, halfMinY(players[c.a].team), halfMaxY(players[c.a].team));
              if (newAy !== A.y) { setPos(c.a, A.x, newAy); any = true; }
            }
          } else {
            if (A.y > B.y - gapY) {
              const newBy = clamp(A.y + gapY, halfMinY(players[c.b].team), halfMaxY(players[c.b].team));
              if (newBy !== B.y) { setPos(c.b, B.x, newBy); any = true; continue; }
              const newAy = clamp(B.y - gapY, halfMinY(players[c.a].team), halfMaxY(players[c.a].team));
              if (newAy !== A.y) { setPos(c.a, A.x, newAy); any = true; }
            }
          }
        } else if (c.type === 'rightOf') {
          if (c.dir === +1) {
            if (A.x < B.x + gapX) {
              const newBx = clamp(A.x - gapX, PADDING, W() - PADDING - size);
              if (newBx !== B.x) { setPos(c.b, newBx, B.y); any = true; continue; }
              const newAx = clamp(B.x + gapX, PADDING, W() - PADDING - size);
              if (newAx !== A.x) { setPos(c.a, newAx, A.y); any = true; }
            }
          } else {
            if (A.x > B.x - gapX) {
              const newBx = clamp(A.x + gapX, PADDING, W() - PADDING - size);
              if (newBx !== B.x) { setPos(c.b, newBx, B.y); any = true; continue; }
              const newAx = clamp(B.x - gapX, PADDING, W() - PADDING - size);
              if (newAx !== A.x) { setPos(c.a, newAx, A.y); any = true; }
            }
          }
        }
      }
      if (!any) break;
    }
  }
  let guides;
function showGuides(on = true){
  if (!on) { guides?.remove(); guides = null; return; }
  if (guides) return;
  guides = document.createElement('div');
  guides.style.cssText = 'position:absolute;inset:0;pointer-events:none;';
  const net = document.createElement('div');
  net.style.cssText = `position:absolute;left:${PADDING}px;right:${PADDING}px;top:${H()/2}px;height:0;border-top:1px dashed #000`;
  const box = document.createElement('div');
  box.style.cssText = `position:absolute;left:${PADDING}px;right:${PADDING}px;top:${PADDING}px;bottom:${PADDING}px;border:1px dashed rgba(0,0,0,.35)`;
  guides.appendChild(net);
  guides.appendChild(box);
  court.appendChild(guides);
}
window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'g') showGuides(!guides);
});

  // --- Initial layout (symmetric, mirrored) ---
function lerp(a,b,t){ return a + (b - a) * t; }

const AUTO_SOLVE = true;
function resetPositions(){
  // Logs stay so we can see what reset is using
  console.table({ W: W(), H: H(), PADDING, netY: H()/2 });

  const netY = H()/2;                          // same as CSS .net (top:50%)
  const left  = PADDING;
  const right = W() - PADDING - size;

  // Columns evenly across the playable width
  const colL = lerp(left, right, 0.15);
  const colM = lerp(left, right, 0.50);
  const colR = lerp(left, right, 0.85);

  // Row offsets from the net (down is +Y)
  const FRONT_OFF = 40;
  const BACK_OFF  = 160;

  // Bottom (below net)
  const botFrontY = netY + 2 + FRONT_OFF;
  const botBackY  = netY + 2 + BACK_OFF;

  // Top (above net) – subtract size so the tokens sit fully above the line
  const topFrontY = netY - size - 2 - FRONT_OFF;
  const topBackY  = netY - size - 2 - BACK_OFF;

  // Place: left → center → right
  // Bottom
  setPos(4, colL, botFrontY); setPos(3, colM, botFrontY); setPos(2, colR, botFrontY);
  setPos(5, colL, botBackY ); setPos(6, colM, botBackY ); setPos(1, colR, botBackY );

  // Top (mirrored visually)
  setPos(12, colL, topFrontY); setPos(13, colM, topFrontY); setPos(14, colR, topFrontY);
  setPos(11, colL, topBackY ); setPos(16, colM, topBackY ); setPos(15, colR, topBackY );

  satisfyAll();

}

/*
function dump(id){ const el = els[id]; console.log(id, el.dataset.x, el.dataset.y); }
dump(4); dump(3); dump(2);
dump(5); dump(6); dump(1);
dump(12); dump(13); dump(14);
dump(11); dump(16); dump(15);
*/

  // --- Dragging ---
  let dragging = null, offset = { x:0, y:0 };
  function onPointerDown(e){
    const el = e.currentTarget; dragging = el;
    const rect = court.getBoundingClientRect();
    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
    offset.x = x - parseFloat(el.dataset.x || '0');
    offset.y = y - parseFloat(el.dataset.y || '0');
    el.setAttribute('aria-grabbed', 'true');
    e.preventDefault();
  }
  function onPointerMove(e){
    if (!dragging) return;
    const rect = court.getBoundingClientRect();
    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left - offset.x;
    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top  - offset.y;
    const id = parseInt(dragging.dataset.pid, 10);
    setPos(id, x, y);
    satisfyAll();
  }
  function onPointerUp(){
    if (dragging) dragging.setAttribute('aria-grabbed','false');
    dragging = null;
  }

  // Attach listeners
  function attach(){
    for (const id of Object.keys(els)) {
      const el = els[id];
      el.addEventListener('mousedown', onPointerDown);
      el.addEventListener('touchstart', onPointerDown, { passive:false });
    }
    window.addEventListener('mousemove', onPointerMove, { passive:true  });
    window.addEventListener('touchmove', onPointerMove, { passive:false });
    window.addEventListener('mouseup',   onPointerUp);
    window.addEventListener('touchend',  onPointerUp);

    resetBtn.addEventListener('click', resetPositions);

    const ro = new ResizeObserver(() => requestAnimationFrame(resetPositions));
    ro.observe(court);
  }

  resetPositions();
  attach();
});
</script>